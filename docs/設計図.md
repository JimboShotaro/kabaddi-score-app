# 進捗・TODO（2026-01-01）

## 途中経過まとめ

- GitHub: https://github.com/JimboShotaro/kabaddi-score-app
- リポジトリのルート: `kabaddi_app/`
- このドキュメントは GitHub 上で進捗を固定するための管理用コピー

## 実装済み（Flutter / ローカル完結）

- 試合ロジック: `MatchEngine`（得点計算、復活、ローナ、スーパータックル等の基本ロジック）
- 単体テスト: MatchEngine のテストが通る状態（得点/復活/ローナ等のケース）
- 画面: ホーム / 新規試合作成 / 試合実行 / 試合履歴 / ルールブック
- UI: コート描画、選手タップ選択、レイド結果記録（成功/タックル/空レイド）、タイマー
- 履歴保存: SharedPreferences による試合履歴保存（Isarは互換性問題で一旦見送り）

## Small Phone（Android Emulator）デバッグ結果

- Android 16 (API 36) / emulator-5554 で起動確認
- 初回は「device is still booting」「offline」等で install が止まったが、エミュレータ再起動→再実行で解消
- `flutter run` で VM Service / DevTools 接続が出るところまで確認

## TODO

### Phase 1〜3（アプリ側の完成度アップ）
- [ ] スコア/レイドの詳細ログ（RaidLog）の永続化（履歴から試合の詳細を再閲覧できる形）
- [ ] 途中終了/試合終了の扱い整理（完了フラグ、終了時刻、結果の確定）
- [ ] UI操作の一貫性確認（レイダー未選択時の導線、選択リセット、誤操作防止）
- [ ] パフォーマンス確認（起動直後にフレームスキップ警告が出るため、重い処理の有無を点検）

### Phase 4（バックエンド / 同期）
- [ ] FastAPI サーバー雛形（/api/v1/sync, /api/v1/analysis/{team_id}）
- [ ] 同期用DTO（Pydantic）と Flutter 側のJSON送信（試合終了後/手動同期）
- [ ] ローカル保存方式の方針決定
	- SharedPreferences継続（軽量・手軽）
	- or Isar再導入（大量データ/検索/耐久性）

---

# カバディ競技支援アプリケーション 総合設計書

（本文は `../設計図.md` の内容を反映）

カバディ競技支援アプリケーション 総合設計書1. プロジェクト概要目的: カバディの複雑な得点計算（復活、ローナ、スーパータックル等）を自動化し、審判・記録員の負荷を軽減する。また、グラフィカルな機能で初心者へのルール普及を支援する。ターゲットプラットフォーム: iOS / Android (Flutterによるクロスプラットフォーム開発)システム特性:即応性: 試合中の操作はすべて端末内で完結させ、ラグのない操作感を提供する。堅牢性: 通信断絶時でもデータが失われないローカルデータベース保存。拡張性: 試合データは後にサーバーへ同期し、Pythonによる分析を可能にする。2. システムアーキテクチャ (System Architecture)モバイル端末（Flutter）が「主」、サーバー（Python）が「従」となる構成です。コード スニペットgraph TD
	subgraph "Mobile App (Flutter / Dart)"
		UI[UI Layer (Widgets)]
		State[State Management (Riverpod)]
		Logic[Domain Logic (Dart)]
		LocalDB[(Local DB: Isar)]
        
		UI --> State
		State --> Logic
		State <--> LocalDB
	end

	subgraph "Backend Server (Python / FastAPI)"
		API[API Gateway]
		Analysis[Analysis Engine (Pandas)]
		CloudDB[(PostgreSQL)]
        
		API --> Analysis
		API <--> CloudDB
	end

	%% 通信フロー
	State -.->|JSON Sync (試合終了後/定期)| API
技術スタック選定理由Flutter (Dart): 単一コードでiOS/Androidに対応。UI描画性能が高く、複雑なアニメーション（選手の移動やルール図解）に適しています。Riverpod: Flutterの標準的な状態管理ライブラリ。テストが容易で、複雑なゲーム状態の制御に最適です。Isar: Flutter向けの超高速NoSQLデータベース。オフライン保存用。FastAPI (Python): データ解析ライブラリが豊富なPythonエコシステムを活用し、蓄積された試合データの統計分析を行うために採用。3. モバイルアプリ詳細設計 (Flutter / Dart)ここが開発の主戦場となります。3.1 ディレクトリ構成Plaintextlib/
├── main.dart
├── core/                   # 共通設定 (定数、テーマ、ユーティリティ)
├── data/                   # データ層
│   ├── models/             # データ型定義 (Player, Match, RaidEvent)
│   ├── repositories/       # IsarやAPIとの通信
│   └── local/              # Isarスキーマ定義
├── domain/                 # ドメイン層 (純粋なロジック)
│   ├── engine/             # カバディ得点計算エンジン
│   └── rules/              # ルール定義 (ボーナスライン条件など)
└── presentation/           # UI層
	├── screens/
	│   ├── home/           # 試合一覧
	│   ├── match/          # 試合実行画面 (スコアボード)
	│   └── rulebook/       # インタラクティブ・ルールブック
	└── widgets/            # 再利用可能なパーツ (コート図など)
3.2 ドメインロジック設計 (Dart)カバディのルールを計算するコアクラスです。UIから分離し、単体テストを可能にします。クラス図 (概念):コード スニペットclassDiagram
	class MatchEngine {
		+MatchState currentState
		+processRaid(RaidResult result) MatchState
		-calculatePoints(RaidResult result)
		-handleRevival(Team team, int count)
		-checkLona(Team defenseTeam)
	}

	class MatchState {
		+int scoreA
		+int scoreB
		+List~Player~ activePlayersA
		+List~Player~ outQueueA
		+List~Player~ activePlayersB
		+List~Player~ outQueueB
	}

	class RaidResult {
		+int raiderId
		+List~int~ touchedDefenderIds
		+bool isBonus
		+bool isRaiderOut
	}

	MatchEngine --> MatchState : Updates
	MatchEngine ..> RaidResult : Uses
実装イメージ (Dart):Dart// domain/engine/match_engine.dart

class MatchEngine {
  // レイド結果を受け取り、新しい試合状態を返す純粋関数
  MatchState processRaid(MatchState current, RaidResult result) {
	// 1. 守備側の人数確認
	final defenders = current.getDefendingTeam(result.raiderTeamId);
	final isSuperTackle = defenders.activeCount <= 3;

	int attackPoints = 0;
	int defensePoints = 0;
    
	// 2. ポイント計算
	if (!result.isRaiderOut) {
	  // 攻撃成功
	  attackPoints += result.touchedDefenderIds.length;
	  if (result.isBonus) attackPoints += 1;
	} else {
	  // 守備成功 (タックル)
	  defensePoints += 1;
	  if (isSuperTackle) defensePoints += 1; // スーパータックル(+1)
	}

	// 3. 復活 (Revival) ロジック & 状態更新
	// ここで新しいImmutableなStateを作成して返す
	return current.copyWith(
	   // ...スコア加算、選手移動、Lona判定後の状態
	);
  }
}
3.3 UI設計: インタラクティブ・ルールブック「読んで覚える」のではなく「触って覚える」画面です。技術: CustomPainter または flutter_svg を使用。機能:コート上のエリア（ロビー、ミッドライン、ボークライン等）をタップ可能にする。タップ時にアニメーション付きで解説モーダルを表示。「レイドシミュレーションモード」: 画面上のドット（選手）を指で動かし、ラインを超えたら「Valid Raid!」と表示されるミニゲーム的な解説機能を搭載。4. バックエンド詳細設計 (Python / FastAPI)サーバーサイドは、アプリから送られてきた結果の「保管庫」兼「分析室」です。4.1 API設計HTTP MethodEndpointDescriptionPOST/api/v1/sync試合終了後、JSON形式で試合ログを一括送信GET/api/v1/analysis/{team_id}特定チームの勝率や得意な攻撃パターンの分析結果を取得4.2 データ同期モデル (Pydantic)アプリから送信されるJSONの構造です。Pythonclass RaidLog(BaseModel):
	raid_number: int
	raider_id: int
	outcome: str  # "SUCCESS", "TACKLED", "EMPTY"
	points_gained: int

class MatchSyncData(BaseModel):
	match_id: str
	date: datetime
	final_score_a: int
	final_score_b: int
	logs: List[RaidLog]
5. 開発ロードマップ (Development Roadmap)以下のステップ順に進めることで、手戻りを防ぎながら着実に完成させます。Phase 1: プロトタイプとコアロジック (期間目安: 1-2週間)目標: 画面は簡素で良いので、カバディの点数計算が正しく行える状態にする。タスク:Flutterプロジェクト作成。MatchEngine (Dart) の実装と単体テスト（特に復活順序とローナのテスト）。最低限のUI（ボタンを押すとログが出て点数が増える）の実装。Phase 2: メインUIの実装 (期間目安: 2週間)目標: 審判が使えるレベルの操作画面を作る。タスク:コート図の描画と、選手アイコンの配置。ドラッグ＆ドロップやタップによる選手選択UIの実装。タイマー機能の実装。Phase 3: インタラクティブ・ルールブック (期間目安: 1-2週間)目標: 初心者向けの解説機能を実装する。タスク:コートのグラフィック作成。各ラインの説明ポップアップ実装。簡単なアニメーション（レイドの軌跡など）の追加。Phase 4: データ永続化とPython連携 (期間目安: 1週間)目標: データの保存とサーバー同期。タスク:Isar (Local DB) の導入、試合データの保存。FastAPIサーバーの立ち上げ。FlutterからPythonへのJSON送信実装。6. 次のアクションまずは Phase 1 として、以下のコマンドでFlutterプロジェクトを作成し、**コアとなる計算ロジック（Dartクラス）**を書き始めることを推奨します。Bashflutter create kabaddi_app
cd kabaddi_app

